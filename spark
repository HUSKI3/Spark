#!/usr/bin/python3

import os
import glob
import sys
import tarfile
import subprocess
import platform
import requests
from pathlib import Path

# 
# ==============================================
#                     Ezconf
# ==============================================
#

import json
import re



class ezconfig:

  def __init__(self):
    self.filename = ""
    self.datajson = None

  def read(self,filename):
    """
    Reads the config file and saves the values
    :return: 
    """
    try:
      with open(str(filename),"r") as f:
        data = f.read()
        #check if the loaded file is json
        try:
          datajson = json.loads(data)
        except Exception as e:
          print('could not load '+str(filename)+', add a basic entry to the config like {"name":"Example"}. Python error: '+str(e))
          return 1
        self.datajson = datajson
        self.filename = filename
        f.close()
        return 0
    except:
      return 1

  def get(self,var,*args):
    """
    Return a variable
    :param var: variable to get
    :return var_val:
    """
    #update datajson
    self.read(self.filename)
    try:
      var_val = self.datajson[str(var)]
      if bool(args)!=False:
        p = re.compile('(?<!\\\\)\'')
        var_val = p.sub('\"', str(var_val))
        return json.loads(str(var_val))[str(args[0])]
    except Exception as e:
      print("[1] could not get variable ["+str(var)+"] does it exist in config.json?\nPython error: "+str(e))
      quit()
    if var_val == None:
      print("[2] could not get variable ["+str(var)+"]. It equals to None, is there a python problem?")
      quit()
    else:
      return var_val
  
  def update(self,var,*args):
    """
    Update a variable
    :param var: variable to update
    """
    #update datajson
    self.read(self.filename)
    try:
      self.datajson[str(var)] = str(args[0])
    except Exception as e:
      merrors.error("could not update variable, does it exist? Did you parse a new value? Python error: "+str(e))
    jsonFile = open(str(self.filename), "w+")
    jsonFile.write(json.dumps(self.datajson))
    jsonFile.close()

  def update_all(self):
    """
    Update all
    """
    jsonFile = open(str(self.filename), "w+")
    jsonFile.write(json.dumps(self.datajson))
    jsonFile.close()

  def pretty(self):
    """
    Return pretty print
    :return prettyprint:
    """
    #update datajson
    self.read(self.filename)
    try:
      return json.dumps(self.datajson, indent=4, sort_keys=True)
    except Exception as e:
      merrors.error("could not pretty print, did you load the config? Python error: "+str(e))
      quit()

  def nested(self,main,name,var):
    self.read(self.filename)
    tmp = []
    try:
      old_nested = self.get(str(main))
    except Exception as e:
      merrors.error("could not create a nested value, does the main value exist? Python error: "+str(e))
      quit()
    for elem in old_nested:
      tmp.append(elem)
    tmp.append({str(name):str(var)})
    self.datajson[str(main)] = tmp
    file = open(str(self.filename), "w")
    json.dump(self.datajson,file)
    file.close()

  def add(self,name,var):
    file = open(str(self.filename), "w")
    self.datajson[str(name)] = str(var)
    json.dump(self.datajson,file)
    file.close()

# 
# ==============================================
#                     Styling
# ==============================================
#

# Setup path and style_file
src = os.path.dirname("~/.config/spark/")
style_file = os.path.join(src, 'style')
rc_file = os.path.join(src, 'sparkrc')

# Setup ezconf
global style
style = ezconfig()
style.read(os.path.expanduser(style_file))

# Colours
RESET = '\033[0m'
def get_color(tuple, background=False):
        r,g,b = tuple
        return '\033[{};2;{};{};{}m'.format(48 if background else 38, r, g, b)

def hex_to_rgb(hex):
        hex = hex.replace('#', '')
        return tuple(int(hex[i:i+2], 16) for i in (0, 2, 4))

#
# ==============================================
#                     Spark
# ==============================================
#

# Colours:
reset = "\u001b[0m"
valid = "\u001b[32m"
fail  = "\u001b[31m"

# Paths
def dirs(sudo):
  try: 
    with open("/usr/spark/spark.check","r") as f:
      f.read()
      return 0
  except:
    if sudo:
      os.system("sudo mkdir -p /usr/spark")
      os.system("sudo mkdir -p /usr/spark/tmp")
      os.system("sudo mkdir -p /usr/spark/packs && sudo touch /usr/spark/packs/installed && sudo touch /usr/spark/spark.check && sudo chmod 777 /usr/spark/packs/installed")
      os.system("sudo mkdir -p /usr/spark/dimensions && sudo touch /usr/spark/dimensions/dimensions.config")
      os.system("sudo mkdir -p /usr/spark/installed/_local")
    else:
      os.system(" mkdir -p /usr/spark")
      os.system(" mkdir -p /usr/spark/tmp")
      os.system(" mkdir -p /usr/spark/packs &&  touch /usr/spark/packs/installed &&  touch /usr/spark/spark.check &&  chmod 777 /usr/spark/packs/installed")
      os.system(" mkdir -p /usr/spark/dimensions &&  touch /usr/spark/dimensions/dimensions.config")
      os.system(" mkdir -p /usr/spark/installed/_local")
    return 1

# Help command
def help():
  print("""
Spark - a simple package manager for IgniteOS

Welcome to spark, the following package manager is in beta and will not work as intended until a stable release is finished.

Usage:
\t spark < -i / install > <package name> = Installs a package
\t spark < -l / list > = Shows installed packages
\t spark < -d / dimension > = Adds dimension
\t spark < -u / update > <package name> = Updates sources
\t spark < -ls / list-sources > = Shows available sources
\t spark < -ci / installed > = Shows intalled packages
""")

# Get dimensions information
def dim():
  dimensions = ezconfig()
  try:
    exit_code = dimensions.read("/usr/spark/dimensions/dimensions.config")
    if exit_code == 1:
        with open("/usr/spark/dimensions/dimensions.config","w+") as f:
          f.write("""{
   "name":"dimensions_config",
   "sources":[{
      "name":"spark_official",
      "url":"https://sparkofficial.ubuntulove2004.repl.co/",
      "date":"",
      "packs":[
         "none"
      ]
   }]
}""")
        return "No dimensions set, fixing... "+valid+"fixed!"+reset
    return 0
  except Exception as e:
    return e

# Update dimensions information
def up_dim(silent=False):
  dimensions = ezconfig()
  try:
    exit_code = dimensions.read("/usr/spark/dimensions/dimensions.config")
    if exit_code == 1:
      return 1
    else:
      for source in dimensions.get('sources'):
        if not silent:
          print("Updating "+source['name']+" on "+source['url']+"... ",end='')
        try:
          r = requests.get(source['url']+'/packs')
          source['packs'] = r.json()
          #print(source)
          dimensions.update_all()
          if not silent:
            print(valid+"✔"+reset)
        except Exception as e:
          print("Failed to update ",source['name'],"reason:",e,fail+"\nPerhaps run as root?")
          return 1
      return 0
  except Exception as e:
    return e

# Checks before install
def run_checks():
  print("Checking paths... ",end="")
  exit_code = dirs(sudo)
  if exit_code == 0:
    print(valid+"✔"+reset)
  else:
    print(fail+"✕ - Created paths"+reset)

  print("Checking dimensions... ",end="")
  exit_code = dim()
  if exit_code == 0:
    print(valid+"✔"+reset)
  else:
    print("\nDimensions file not found? Please run: \n\tspark update\n")
    print(fail+"✕ - "+str(exit_code)+reset)
    quit()

# Update
def update(silent=False):
  if not silent:
    print("Checking for dimensions file... ",end="")
  exit_code = dim()
  if exit_code == 0:
    if not silent:
      print(valid+"✔"+reset)
  else:
    if not silent:
      print(fail+"✕ - "+str(exit_code)+reset)
      quit()
    else:
      quit()
  if not silent:
    print("Updating dimensions file... ")
  exit_code = up_dim(silent=True)
  if exit_code == 0:
    if not silent:
      print(valid+"Updated All ✔"+reset)
  else:
    if not silent:
      print(fail+"Failed to Update ✕"+reset)
    quit()

# Find package
def find_pkg(name,dimensions):
  for source in dimensions.get('sources'):
    for pack in source['packs']:
      if name == pack['name']:
        return pack
  return None

# Install
def install(package,force=False):
  dimensions = ezconfig()
  # check if it exists
  print("Reading dimensions file... ",end="")
  exit_code = dimensions.read("/usr/spark/dimensions/dimensions.config")
  if exit_code == 0:
    print(valid+"✔"+reset)
  else:
    print(fail+"✕ - "+str(exit_code)+reset)
    quit()
  print("Checking if package is installed... "+valid+"✔"+reset)
  #print(get_local_version(package))
  #nput()
  if not force:
    if check_installed(package):
      pack = find_pkg(package,dimensions)
      if pack['version'] != get_installed_version(package):
        print("Package is installed but a new version is available")
      elif pack['version'] == get_installed_version(package):
        print("Package is already installed at the version",get_installed_version(package))
        print("Repo latest is",pack['version'])
        quit()
      else:
        print("Package is installed to the latest recommended version")
  print("Preparing to install",package,"..."+valid+"✔"+reset)
  pack = find_pkg(package,dimensions)
  if pack == None:
    print("No candidates with the name",package)
    quit()
  if pack['depends'] == "none":
      deps = None
      predeps = "none"
  else:
    deps = []
    predeps = pack['depends']
    for dep in predeps:
      #print("dep in predeps 1 loop:",dep)
      tempdep = find_pkg(dep,dimensions)
      if tempdep['depends'] != "none":
        if type(tempdep['depends']) is str:
          predeps.append(tempdep['depends'])
        elif type(tempdep['depends']) is list:
          for dep in tempdep['depends']:
            print(dep)
            predeps.append(dep)
  print(valid)
  print("Name:",pack['name'])
  if get_local_version(pack['name']) != False:
    print("Version:",pack['version'],"({} is installed)".format(get_local_version(pack['name'])))
  else:
    print("Version:",pack['version'])
  print("Size:",pack['size'],"mb - upon installation")
  print("Depends on:",predeps)
  print(reset)
  inp = input("Install? [y/n] ")
  if inp == "y" or inp == "Y":
    if pack['depends'] != "none":
      predeps.reverse()
      for dep in predeps:
        #print("dep in predep 2 loop:",dep)
        if check_installed(dep) and not force:
          print("installed already")
        else:
          dpack = find_pkg(dep,dimensions)
          get_src(dpack['url'],dep)
          unpack(dep)
          build(dep,dpack['build'])
          print(dep,dpack)
          add_installed(dpack['name'])
          #input()
    get_src(pack['url'],pack['name'])
    unpack(pack['name'])
    build(pack['name'],pack['build'])

    return True
  return False

# Uninstall
def uninstall(package,force=False):
  installed = ezconfig()
  installed.read("/usr/spark/installed.json")
  ver = None
  for pack in installed.get('packages'):
    if pack == package:
      ver = installed.get('packages')[package]['version']
      print("Found",package,"version",ver," "+valid+"✔"+reset)
      print("Locating in ~/.local/_dist/"+package,end="... ")
      ver_found = True
  if ver == None:
    print("Failed to locate package",end=" ")
    ver_found = False
  #print('~/.local/_dist/'+package)
  # if test -d ~/.local/_dist/emacs; then echo "exist"; fi 
  #a=  os.popen('whoami').read()
  #print(a)
  #os.system('whoami')
  if "y" in os.popen(f'if test -d ~/.local/_dist/{package}; then echo "y"; fi ').read():
    print(valid+"✔"+reset)
    # Fuckery here
    '''
    cd $HOME/.local
    for file in $(tar tzf package.tgz | grep -v '/$'); do
        rm -f "$file"
    done
    '''
    #os.system("cd /root/.local/_dist/"+package+"/ && ls")
    txt = glob.glob("/root/.local/_dist/"+package+"/*.tar*")
    for tar in txt:
      os.system("rm -rf "+tar)
    path_dir = glob.glob("/root/.local/_dist/"+package+"/"+package+"*")[0]
    #print(path_dir)
    #quit()
    make_dir = glob.glob(path_dir+"/Makefile*")[0]
    #print(make_dir)
    with open(make_dir) as file:
      make = file.read()
      if "uninstall" in make:
        #print("Makefile has uninstall!")
        c = input("Uninstall? [Y/N] ")
        if c == "y" or c == "Y":
          os.system("cd "+path_dir+" && make uninstall")
          return True
        else:
          return False
  else:
    print(fail+"✕"+reset)
    if ver_found:
      print(fail+"Package is installed but the source path is missing!"+reset)
      print("If you manually removed the package,\nwould you like to remove it's entry?")
      c = input("Remove? [Y/N] ")
      if c == "Y" or c == "y":
        return True
      else:
        return False
    else:
      print(fail+"Package is not installed!"+reset)
    quit()
  

# Get package source
def get_src(uri,packname):
  print("Downloading source from ",uri,"...")
  os.system("cd /usr/spark/tmp && rm -r "+packname+"*")
  os.system("cd /usr/spark/tmp && wget -q "+uri)

def unpack(packname):
  os.system("cd /usr/spark/tmp && tar xf "+packname+"* && ls") 
  os.system("mkdir ~/.local/_dist")
  os.system("mkdir ~/.local/_dist/"+packname) 

def build(packname,buildinst):
  os.system("cd /usr/spark/tmp/"+packname+"* && "+buildinst) 
  # cd /usr/spark/tmp && sudo cp -r emacs* ~/.local/_dist/emacs
  os.system("cd /usr/spark/tmp && cp -r "+packname+"* ~/.local/_dist/"+packname)

def list_packs():
  dimensions = ezconfig()
  dimensions.read("/usr/spark/dimensions/dimensions.config")
  for source in dimensions.datajson['sources']:
    print(fail+source['name']+reset,"has:")
    for pack in source['packs']:
      print(pack['name'],"version",pack['version'])

def get_version(name):
  dimensions = ezconfig()
  dimensions.read("/usr/spark/dimensions/dimensions.config")
  for source in dimensions.datajson['sources']:
    #print(fail+source['name']+reset,"has:")
    for pack in source['packs']:
      if pack['name'] == name:
        return pack['version']
      else:
        #print(pack['name'],name,"no match")
        continue
  return False

def get_local_version(name):
  installed = ezconfig()
  installed.read("/usr/spark/installed.json")
  for pack in installed.get('packages'):
    if pack == name:
      return installed.get('packages')[pack]['version']
    else:
      #print(pack['name'],name,"no match")
      continue
  return False


def list_sources():
  dimensions = ezconfig()
  dimensions.read("/usr/spark/dimensions/dimensions.config")
  for source in dimensions.datajson['sources']:
    print(valid+source['name']+reset)

def add_dimension(url):
  dimensions = ezconfig()
  print("Contacting source... ",end='')
  r = requests.get(url+'/')
  print(valid+"✔"+reset)
  dimensions.read("/usr/spark/dimensions/dimensions.config")
  print("Saving source... ",end='')
  dimensions.datajson['sources'].append(r.json())
  dimensions.update_all()
  print(valid+"✔"+reset)

def add_installed(name):
  dimensions = ezconfig()
  # check if it exists
  print("Reading dimensions file... ",end="")
  exit_code = dimensions.read("/usr/spark/dimensions/dimensions.config")
  if exit_code == 0:
    print(valid+"✔"+reset)
  else:
    print(fail+"✕ - "+str(exit_code)+reset)
    quit()
  installed = ezconfig()
  pack = find_pkg(name,dimensions)
  try:
    exit_code = installed.read("/usr/spark/installed.json")
    if exit_code == 1:
      "First install?"
      print("This is your first package installed using spark!")
      print("No installed file, fixing... "+valid+"fixed!"+reset)
      with open("/usr/spark/installed.json","w+") as f:
          f.write("""
            {
            "packages":
            {
              "spark":{
              "version":"0.0.0",
              "source":"github.com/HUSKI3/Spark",
              "depends":"none"}
              
            }
}
            """)
  except Exception as e:
    print(e)
    quit()
  packs = installed.get("packages")
  #print(packs)
  packs[name] ={
    "version":pack['version'],
    "source":pack['url'],
    "depends":pack['depends']
  }
  #print(packs)
  installed.update_all()

def remove_installed(name):
  dimensions = ezconfig()
  # check if it exists
  print("Reading dimensions file... ",end="")
  exit_code = dimensions.read("/usr/spark/dimensions/dimensions.config")
  if exit_code == 0:
    print(valid+"✔"+reset)
  else:
    print(fail+"✕ - "+str(exit_code)+reset)
    quit()
  installed = ezconfig()
  pack = find_pkg(name,dimensions)
  try:
    exit_code = installed.read("/usr/spark/installed.json")
    if exit_code == 1:
      "First install?"
      print("No packages are installed.")
  except Exception as e:
    print(e)
    quit()
  packs = installed.get("packages")
  del packs[name]
  installed.update_all()
  print("Removed! "+valid+"✔"+reset)

def list_installed():
  print("Reading... ",end="")
  update_avail = False
  installed = ezconfig()
  exit_code = installed.read("/usr/spark/installed.json")
  if exit_code == 0:
    print(valid+"✔"+reset)
  else:
    print(fail+"✕ - "+str(exit_code)+reset)
    quit()
  #print(installed.get('packages'))
  for package in installed.get('packages'):
    # weird
    pkg = installed.get('packages')[package]
    #print(pkg)
    if pkg['version'] != get_version(package) and get_version(package) != False:
      print(valid+"[UPDATE]"+reset,package,"at",pkg['version']+", an update is available to",get_version(package))
      update_avail = True
    else:
      print(package,"at",pkg['version'])
  if update_avail:
    print("Shard is required to update packages!")

def get_installed_version(name):
  installed = ezconfig()
  exit_code = installed.read("/usr/spark/installed.json")
  #print(installed.datajson['packages'][name])
  for package in installed.datajson['packages'][name]:
    if package == name:
      pkg = installed.get('packages')[package]
      #print(pkg)
      #quit()
      return pkg
  return None
    
  
def check_installed(name):
  installed = ezconfig()
  exit_code = installed.read("/usr/spark/installed.json")
  #print(installed.get('packages'))
  for package in installed.get('packages'):
    if name == package:
      return True
  return False

def main(*argv): 
  # Check arguments
  argv=argv[0]
  global sudo
  if "--no-sudo" in argv:
    sudo = False
  else:
    sudo = True
  if "-h" in argv or "help" in argv:
    help()
  elif "-i" in argv or "install" in argv:
    update()
    if "-r" in argv:
      run_checks()
      if install(argv[-1], force=True):
        add_installed(argv[-1])
    else:
      run_checks()
      if install(argv[-1]):
        add_installed(argv[-1])
  elif "-ci" in argv or "installed" in argv:
    update()
    list_installed()
  elif "-u" in argv or "update" in argv:
    run_checks()
    update()
  elif "-d" in argv or "dimension" in argv:
    run_checks()
    add_dimension(argv[-1])
    update()
  elif "-l" in argv or "list" in argv:
    list_packs()
  elif "-un" in argv or "uninstall" in argv:
    run_checks()
    if uninstall(argv[-1]):
      remove_installed(argv[-1])
  elif "-c" in argv or "clean" in argv:
    run_checks()
    os.system("cd /usr/spark/tmp && rm -r *")
    update()
  elif "-ls" in argv or "list-sources" in argv:
    run_checks()
    list_sources()
  elif "-nv" in argv:
    update(silent=True)
    print({
      "installed":get_local_version(argv[-1]),
      "latest":get_version(argv[-1])
      })
  else:
    help()

if __name__ == "__main__":
 main(sys.argv)